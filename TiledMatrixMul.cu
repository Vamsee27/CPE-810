//Name: Vamsee Krishna Tunuguntla
//CWID: 20009051

//Lab1: Matrix Multiplication 

//Note: 1.Code is written in a way where it accepts 3 arguments i.e.,rolDimM, colDimM, colDimN to perform matrix multiplication.
//2. colDimM = rowDimN i.e., It allows the matrix multiplication.
//3. Have used device memory to perform computations.

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define TILE_WIDTH 32


__global__ void MatrixMulKernel(float* M, float* N, float* P, int rowDimM, int colDimM, int colDimN)
{
    __shared__ float ds_M[TILE_WIDTH][TILE_WIDTH];
    __shared__ float ds_N[TILE_WIDTH][TILE_WIDTH];

    int bx = blockIdx.x;  int by = blockIdx.y;
    int tx = threadIdx.x; int ty = threadIdx.y;

    int row = by * TILE_WIDTH + ty;
    int col = bx * TILE_WIDTH + tx;

    float Pvalue = 0;

    for (int p = 0; p < ceil((float)colDimM/TILE_WIDTH); ++p) {

        if (row < rowDimM && p*TILE_WIDTH+tx < colDimM) {
            ds_M[ty][tx] = M[row*colDimM + p*TILE_WIDTH+tx];
        } else {
            ds_M[ty][tx] = 0.0;
        }

        if (col < colDimN && p*TILE_WIDTH+ty < colDimM) {
            ds_N[ty][tx] = N[(p*TILE_WIDTH+ty)*colDimN + col];
        } else {
            ds_N[ty][tx] = 0.0;
        }

        __syncthreads();

        for (int i = 0; i < TILE_WIDTH; ++i) {
            Pvalue += ds_M[ty][i] * ds_N[i][tx];
        }

        __syncthreads();
    }

    if (row < rowDimM && col < colDimN) {
        P[row*colDimN+col] = Pvalue;
    }
}

void displayMatrix(float* matrix, int numRows, int numCols) {
    for (int i = 0; i < numRows; i++) {
        for (int j = 0; j < numCols; j++) {
            printf("%.2f ", matrix[i*numCols + j]);
        }
        printf("\n");
    }
}


int main(int argc, char **argv)
{
    int rowDimM, colDimM, colDimN;
		
    // Parse command line arguments
    
    if (argc != 4) {
        printf("Usage: %s <rowDimM> <colDimM> <colDimN>\n", argv[0]);
        return 1;
   	 }

    rowDimM = atoi(argv[1]);
    colDimM = atoi(argv[2]);
    colDimN = atoi(argv[3]);
    
    // Allocate memory on host
    
    float *h_M, *h_N, *h_P;
    h_M = (float*)malloc(rowDimM * colDimM  * sizeof(float));
    h_N = (float*)malloc(colDimM * colDimN  * sizeof(float));
    h_P = (float*)malloc(rowDimM * colDimN  * sizeof(float));

    // Initialize matrices M and N with random values
    
    srand(time(NULL));
    
    for (int i = 0; i < rowDimM; i++) {
        for (int j = 0; j < colDimM; j++) {
            h_M[i * colDimM + j] = (float)(rand() % 10 + 1);
        }
    }
    
    printf("\n");	
    printf("Print Matrix M generated by random numbers:");	
    printf("\n");
    displayMatrix(h_M, rowDimM, colDimM);

    for (int i = 0; i < colDimM; i++) {
        for (int j = 0; j < colDimN; j++) {
            h_N[i * colDimN + j] = (float)(rand() % 10 + 1);
        }
    }
    
    printf("\n");
    printf("Print Matrix N generated by random numbers:");	
    printf("\n");
    displayMatrix(h_N, colDimM, colDimN);

    // Allocate memory on device
    
    float *d_M, *d_N, *d_P;
    
    cudaMalloc(&d_M, rowDimM * colDimM * sizeof(float));
    cudaMalloc(&d_N, colDimM * colDimN * sizeof(float));
    cudaMalloc(&d_P, rowDimM * colDimN * sizeof(float));

    // Copy matrices M and N from host to device

    cudaMemcpy(d_M, h_M, rowDimM * colDimM * sizeof(float), cudaMemcpyHostToDevice);
    cudaMemcpy(d_N, h_N, colDimM * colDimN * sizeof(float), cudaMemcpyHostToDevice);

    // Define thread block and kernel grid dimensions
	
    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);	
    dim3 dimGrid(ceil((float)colDimN / dimBlock.x), ceil((float)rowDimM / dimBlock.y));

    // Invoke CUDA kernel
	
    MatrixMulKernel<<<dimGrid, dimBlock>>>(d_M, d_N, d_P, rowDimM, colDimM, colDimN);

    // Copy result matrix from device to host
	
    cudaMemcpy(h_P, d_P, rowDimM * colDimN * sizeof(float), cudaMemcpyDeviceToHost);
	
    printf("\n");	
    printf("Print Matrix P=M*N:");	
    printf("\n");	
    displayMatrix(h_P, rowDimM, colDimN);
	
    // Free device memory
	
    cudaFree(d_M);	
    cudaFree(d_N);	
    cudaFree(d_P);

    printf("Matrix Multiplication done");
}
